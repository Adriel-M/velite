import { mkdir, rm, writeFile } from 'node:fs/promises'
import { join, relative } from 'node:path'
import glob from 'fast-glob'
import { reporter } from 'vfile-reporter'

import { clearCache } from './cache'
import { getConfig, resolveConfig } from './config'
import { parse } from './file'
import { logger } from './logger'

import type { Config } from './config'
import type { Entry } from './file'
import type { LogLevel } from './logger'

/**
 * generate entry from config.collections
 * @returns entry content and dts
 */
const generateEntry = async () => {
  const { configPath, output, collections } = getConfig()
  const configModPath = relative(output.data, configPath)
    .replace(/\\/g, '/') // replace windows path separator
    .replace(/\.[mc]?[jt]s$/i, '') // remove extension
  const entry: string[] = []
  const dts: string[] = [`import config from '${configModPath}'\n`]
  Object.entries(collections).map(([name, collection]) => {
    const funcName = `get${name[0].toUpperCase() + name.slice(1)}` // getPosts
    entry.push(`export const ${funcName} = async () => await import('./${name}.json').then(m => m.default)\n`)
    dts.push(`export type ${collection.name} = NonNullable<typeof config.collections>['${name}']['schema']['_output']`)
    dts.push(`export declare const ${funcName}: () => Promise<${collection.name + (collection.single ? '' : '[]')}>\n`)
  })
  return [entry.join('\n'), dts.join('\n')] as const
}

/**
 * emit result to dist
 */
const emit = async (result: Record<string, Entry | Entry[]>, dest: string) => {
  await mkdir(dest, { recursive: true })
  const logs: string[] = []
  await Promise.all(
    Object.entries(result).map(async ([name, data]) => {
      if (data == null) return
      const target = join(dest, name + '.json')
      await writeFile(target, JSON.stringify(data, null, 2))
      logger.log(`wrote ${data.length ?? 1} ${name} in '${target}'`)
      logs.push(`${data.length ?? 1} ${name}`)
    })
  )

  const [entry, dts] = await generateEntry()
  const banner = '// This file is generated by Velite\n\n'

  const entryFile = join(dest, 'index.js')
  await writeFile(entryFile, banner + entry)
  logger.log(`wrote entry file in '${entryFile}'`)

  const dtsFile = join(dest, 'index.d.ts')
  await writeFile(dtsFile, banner + dts)
  logger.log(`wrote entry dts file in '${dtsFile}'`)

  logger.info(`output ${logs.join(', ')} and entry file`)
}

/**
 * build done
 * @param result loaded entries
 * @param dest output directory
 * @param prepare prepare hook
 * @param complete complete hook
 */
const done = async (result: Record<string, Entry | Entry[]>, dest: string, prepare: Config['prepare'], complete: Config['complete']) => {
  let prevent = false

  // apply prepare hook
  if (typeof prepare === 'function') {
    const flag = await prepare(result as any)
    if (flag === false) {
      prevent = true
    }
    logger.log(`executed 'prepare' callback got ${flag == null ? 'no' : flag} result`)
  }

  if (prevent) {
    logger.warn(`prevent output by 'prepare' callback`)
  } else {
    // emit result if not prevented
    await emit(result, dest)
  }

  // call complete hook
  if (typeof complete === 'function') {
    await complete()
    logger.log(`executed 'complete' callback`)
  }
}

/**
 * load collections from content root
 * @param root content root
 * @param collections collections
 * @returns loaded entries
 */
const load = async (root: string, collections: Config['collections']): Promise<Record<string, Entry | Entry[]>> => {
  logger.log(`searching files in '${root}'`)
  const tasks = Object.entries(collections).map(async ([name, collection]) => {
    const filenames = await glob(collection.pattern, { cwd: root, onlyFiles: true, ignore: ['**/_*'], absolute: true })
    logger.log(`found ${filenames.length} files matching '${collection.pattern}'`)
    const files = await Promise.all(filenames.map(filename => parse(filename, collection.schema)))

    // report if any error in parsing
    const report = reporter(files, { quiet: true })
    report.length > 0 && logger.warn(report)

    // prettier-ignore
    const data = files.map(file => file.data.parsed).flat().filter(Boolean) as Entry[]

    if (collection.single) {
      if (data.length === 0) {
        throw new Error(`parsed ${data.length} items for '${name}', but expected only one`)
      } else if (data.length > 1) {
        logger.warn(`parsed ${data.length} items for '${name}', but expected only one, using first one`)
      } else {
        logger.log(`parsed ${data.length} items for '${name}'`)
      }
      return [name, data[0]] as const
    }

    logger.log(`parsed ${data.length} items for '${name}'`)
    return [name, data] as const
  })

  const entities = await Promise.all(tasks)

  return Object.fromEntries<Entry | Entry[]>(entities)
}

/**
 * watch files and rebuild on changes
 * @param config resolved config
 */
const watch = async (config: Config) => {
  const chokidar = await import('chokidar')
  logger.info(`watching for changes in '${config.root}'`)

  const files = Object.values(config.collections).map(schema => schema.pattern)
  files.push(config.configPath) // watch config file changes

  chokidar
    .watch(files, {
      cwd: config.root,
      ignored: /(^|[\/\\])[\._]./, // ignore dot & underscore files
      ignoreInitial: true, // ignore initial scan
      awaitWriteFinish: { stabilityThreshold: 50, pollInterval: 10 }
    })
    .on('all', async (event, filename) => {
      if (filename == null) return
      const start = Date.now()

      if (filename === relative(config.root, config.configPath)) {
        // reload config if config file changed
        logger.info(`config changed '${filename}', reloading...`)
        config = await resolveConfig({ path: config.configPath })
      } else {
        logger.info(`file changed '${filename}', rebuilding...`)
      }

      clearCache() // clear cache
      await load(config.root, config.collections)
        .then(result => done(result, config.output.data, config.prepare, config.complete))
        .catch(logger.warn)
      logger.info(`build finished in ${Date.now() - start}ms`)
    })
}

/**
 * build options
 */
export interface BuildOptions {
  /**
   * Specify config file path
   * @default 'velite.config.{js,ts,mjs,mts,cjs,cts}'
   */
  config?: string
  /**
   * Clean output directories before build
   * @default false
   */
  clean?: boolean
  /**
   * Watch files and rebuild on changes
   * @default false
   */
  watch?: boolean
  /**
   * Production mode
   * @default false
   */
  production?: boolean
  /**
   * Log level
   * @default 'info'
   */
  logLevel?: LogLevel
}

/**
 * build contents
 * @param options build options
 */
export const build = async (options: BuildOptions = {}) => {
  const start = Date.now()
  const { config: configFile, clean, logLevel } = options

  // resolve config
  const config = await resolveConfig({ path: configFile, clean, logLevel })

  // prerequisite
  if (config.output.clean) {
    // clean output directories if `--clean` requested
    await rm(config.output.data, { recursive: true, force: true })
    logger.log(`cleaned data output dir '${config.output.data}'`)

    await rm(config.output.assets, { recursive: true, force: true })
    logger.log(`cleaned assets output dir '${config.output.assets}'`)
  }

  const result = await load(config.root, config.collections)
  await done(result, config.output.data, config.prepare, config.complete)

  logger.info(`build finished in ${Date.now() - start}ms`)

  // watch files
  if (options.watch !== true) return

  watch(config)
}

//   /**
//    * watch config file changes and reinit builder
//    */
//   private async watchConfig() {
//     const { configPath } = getConfig()

//     logger.info(`watching for changes in '${configPath}'`)

//     for await (const event of watch(configPath)) {
//       const { filename } = event
//       if (filename == null) continue

//       logger.info(`config changed '${filename}', rebuilding...`)

//       await this.init()
//         .then(() => this.build())
//         .catch(logger.warn)
//     }
//   }

//   /**
//    * watch content files changes and rebuild
//    */
//   private async watchRoot() {
//     const { root, collections } = getConfig()
//     const allPatterns = Object.values(collections).map(schema => schema.pattern)

//     logger.info(`watching for changes in '${root}'`)

//     // TOOD: recursive watch not working on linux
//     // The `fs.watch()` recursive option is only supported on macOS and Windows.
//     // Maybe Chokidar is a better choice.
//     // https://github.com/nodejs/node/issues/36005
//     for await (const event of watch(root, { recursive: process.platform !== 'linux' })) {
//       const { filename } = event
//       if (filename == null) continue
//       if (!allPatterns.some(pattern => micromatch.isMatch(filename, pattern))) continue

//       logger.info(`file changed '${filename}', rebuilding...`)

//       await this.build(filename).catch(logger.warn)
//     }
//   }

//   /**
//    * start watching
//    */
//   watch() {
//     // logger.clear()
//     this.watchConfig()
//     this.watchRoot()
//   }
// }
